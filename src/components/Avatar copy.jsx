/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 public/models/68dcaeb39603200be5283efd (1).glb -o src/components/Avatar.jsx -k -r public
*/

import { useAnimations, useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { button, useControls } from "leva";
import React, { useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { useChat } from "../hooks/useChat";

// ---------- utils / constants ----------
const clamp = THREE.MathUtils.clamp;
const lerp = THREE.MathUtils.lerp;

const VISEME_INTENSITY = 1.25; // bolder mouth shapes
const VISEME_LERP = 0.28;      // quicker viseme changes
const JAW_GAIN = 1.35;         // energy -> jaw openness
const JAW_MIN = 0.02;          // baseline jaw while talking
const WORD_CLOSURE = 0.07;     // quick PP between words

const facialExpressions = {
  default: {},
  smile: { browInnerUp: 0.17, eyeSquintLeft: 0.4, eyeSquintRight: 0.44, noseSneerLeft: 0.17, noseSneerRight: 0.14, mouthPressLeft: 0.61, mouthPressRight: 0.41 },
  funnyFace: { jawLeft: 0.63, mouthPucker: 0.53, noseSneerLeft: 1, noseSneerRight: 0.39, mouthLeft: 1, eyeLookUpLeft: 1, eyeLookUpRight: 1, cheekPuff: 1, mouthDimpleLeft: 0.4147, mouthRollLower: 0.32, mouthSmileLeft: 0.355, mouthSmileRight: 0.355 },
  sad: { mouthFrownLeft: 1, mouthFrownRight: 1, mouthShrugLower: 0.78341, browInnerUp: 0.452, eyeSquintLeft: 0.72, eyeSquintRight: 0.75, eyeLookDownLeft: 0.5, eyeLookDownRight: 0.5, jawForward: 1 },
  surprised: { eyeWideLeft: 0.5, eyeWideRight: 0.5, jawOpen: 0.351, mouthFunnel: 1, browInnerUp: 1 },
  angry: { browDownLeft: 1, browDownRight: 1, eyeSquintLeft: 1, eyeSquintRight: 1, jawForward: 1, jawLeft: 1, mouthShrugLower: 1, noseSneerLeft: 1, noseSneerRight: 0.42, eyeLookDownLeft: 0.16, eyeLookDownRight: 0.16, cheekSquintLeft: 1, cheekSquintRight: 1, mouthClose: 0.23, mouthFunnel: 0.63, mouthDimpleRight: 1 },
  crazy: { browInnerUp: 0.9, jawForward: 1, noseSneerLeft: 0.57, noseSneerRight: 0.51, eyeLookDownLeft: 0.394, eyeLookUpRight: 0.404, eyeLookInLeft: 0.962, eyeLookInRight: 0.962, jawOpen: 0.962, mouthDimpleLeft: 0.962, mouthDimpleRight: 0.962, mouthStretchLeft: 0.279, mouthStretchRight: 0.289, mouthSmileLeft: 0.558, mouthSmileRight: 0.385, tongueOut: 0.962 },
};

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP",
};

let setupMode = false;

export function Avatar(props) {
  const { nodes, materials, scene } = useGLTF("/models/68dcaeb39603200be5283efd (1).glb");
  const { message, onMessagePlayed, chat } = useChat();

  // ---------- audio / lipsync state ----------
  const [lipsync, setLipsync] = useState();
  const audioCtxRef = useRef(null);
  const analyserRef = useRef(null);
  const dataRef = useRef(null);
  const [audio, setAudio] = useState(null);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [energy, setEnergy] = useState(0);

  // ---------- animations ----------
  const { animations } = useGLTF("/models/animations.glb");
  const group = useRef();
  const { actions, mixer } = useAnimations(animations, group);
  const [animation, setAnimation] = useState(
    animations.find((a) => a.name === "Idle") ? "Idle" : animations[0].name
  );

  useEffect(() => {
    actions[animation].reset().fadeIn(mixer.stats.actions.inUse === 0 ? 0 : 0.5).play();
    return () => actions[animation].fadeOut(0.5);
  }, [animation]);

  // ---------- hand/arm bones & gesture state ----------
  const leftArm = useRef(null);
  const leftForeArm = useRef(null);
  const leftHand = useRef(null);
  const rightArm = useRef(null);
  const rightForeArm = useRef(null);
  const rightHand = useRef(null);

  const gesturePulse = useRef(0);
  const lastPulseAt = useRef(0);

  useEffect(() => {
    const findBone = (names) => {
      for (const n of names) {
        const b = scene.getObjectByName(n);
        if (b) return b;
      }
      return null;
    };
    // Wolf3D / Mixamo naming coverage
    leftArm.current      = findBone(["LeftArm","mixamorigLeftArm"]);
    leftForeArm.current  = findBone(["LeftForeArm","mixamorigLeftForeArm"]);
    leftHand.current     = findBone(["LeftHand","mixamorigLeftHand"]);
    rightArm.current     = findBone(["RightArm","mixamorigRightArm"]);
    rightForeArm.current = findBone(["RightForeArm","mixamorigRightForeArm"]);
    rightHand.current    = findBone(["RightHand","mixamorigRightHand"]);
  }, [scene]);

  // ---------- play audio + set up analyser on each message ----------
  useEffect(() => {
    if (!message) {
      setAnimation("Idle");
      setIsSpeaking(false);
      return;
    }
    setAnimation(message.animation || "Idle");
    setFacialExpression(message.facialExpression || "default");
    setLipsync(message.lipsync);

    const el = new Audio("data:audio/mp3;base64," + message.audio);
    el.crossOrigin = "anonymous";
    el.play();

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = audioCtxRef.current ?? new AudioContext();
    audioCtxRef.current = ctx;

    const src = ctx.createMediaElementSource(el);
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;
    const buf = new Uint8Array(analyser.fftSize);

    src.connect(analyser);
    analyser.connect(ctx.destination);

    analyserRef.current = analyser;
    dataRef.current = buf;

    setAudio(el);
    setIsSpeaking(true);

    el.onended = () => {
      setIsSpeaking(false);
      onMessagePlayed();
    };
  }, [message]);

  // ---------- helpers ----------
  function rmsFromAnalyser(analyser, buf) {
    analyser.getByteTimeDomainData(buf);
    let sum = 0;
    for (let i = 0; i < buf.length; i++) {
      const v = (buf[i] - 128) / 128; // -1..1
      sum += v * v;
    }
    return Math.sqrt(sum / buf.length); // 0..~1
  }

  const lerpMorphTarget = (target, value, speed = 0.1) => {
    scene.traverse((child) => {
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        const index = child.morphTargetDictionary[target];
        if (index === undefined || child.morphTargetInfluences[index] === undefined) return;
        child.morphTargetInfluences[index] = THREE.MathUtils.lerp(
          child.morphTargetInfluences[index],
          value,
          speed
        );
        if (!setupMode) {
          try { set({ [target]: value }); } catch (_) {}
        }
      }
    });
  };

  // ---------- blink / expression ----------
  const [blink, setBlink] = useState(false);
  const [winkLeft, setWinkLeft] = useState(false);
  const [winkRight, setWinkRight] = useState(false);
  const [facialExpression, setFacialExpression] = useState("");

  // ---------- per-frame logic ----------
  useFrame(() => {
    // Emotion blend
    if (!setupMode) {
      Object.keys(nodes.EyeLeft.morphTargetDictionary).forEach((key) => {
        if (key === "eyeBlinkLeft" || key === "eyeBlinkRight") return;
        const mapping = facialExpressions[facialExpression];
        const targetVal = mapping && mapping[key] ? mapping[key] : 0;
        lerpMorphTarget(key, targetVal, 0.1);
      });
    }

    // Energy from audio
    const energyNow = (() => {
      if (!analyserRef.current || !dataRef.current || !isSpeaking) return 0;
      const e = rmsFromAnalyser(analyserRef.current, dataRef.current);
      const shaped = clamp(Math.pow(e * 1.8, 1.3), 0, 1);
      setEnergy(shaped);
      return shaped;
    })();

    // Hand gesture (speaking only)
    {
      const speakingAmp = isSpeaking ? (0.18 + energyNow * 0.35) : 0;
      const t = audio?.currentTime || 0;

      const L = { z: Math.sin(t * 2.2) * speakingAmp,     y: Math.sin(t * 1.6 + 0.6) * speakingAmp };
      const R = { z: Math.sin(t * 2.0 + Math.PI * 0.35) * speakingAmp, y: Math.sin(t * 1.7 + 1.1) * speakingAmp };

      const now = t;
      const shouldPulse = isSpeaking && energyNow > 0.55 && (now - lastPulseAt.current) > 0.8;
      if (shouldPulse) {
        gesturePulse.current = 1.0;
        lastPulseAt.current = now;
      }
      gesturePulse.current = Math.max(0, gesturePulse.current - (isSpeaking ? 0.08 : 0.12));

      const pulseZ = gesturePulse.current * 0.35; // radians
      const damp = 0.18;

      if (leftForeArm.current)  leftForeArm.current.rotation.z  = lerp(leftForeArm.current.rotation.z,  L.z + pulseZ, damp);
      if (rightForeArm.current) rightForeArm.current.rotation.z = lerp(rightForeArm.current.rotation.z, -R.z + pulseZ, damp);
      if (leftHand.current)     leftHand.current.rotation.y     = lerp(leftHand.current.rotation.y,     L.y, damp);
      if (rightHand.current)    rightHand.current.rotation.y    = lerp(rightHand.current.rotation.y,   -R.y, damp);

      if (leftArm.current)  leftArm.current.rotation.x  = lerp(leftArm.current.rotation.x,  0.04 * speakingAmp, 0.12);
      if (rightArm.current) rightArm.current.rotation.x = lerp(rightArm.current.rotation.x, 0.03 * speakingAmp, 0.12);
    }

    // Blink dampening while speaking
    const blinkDampen = clamp(1 - energyNow * 0.8, 0.15, 1);
    lerpMorphTarget("eyeBlinkLeft",  (blink || winkLeft  ? 1 : 0) * blinkDampen, 0.5);
    lerpMorphTarget("eyeBlinkRight", (blink || winkRight ? 1 : 0) * blinkDampen, 0.5);

    if (setupMode) return;

    // Visemes
    const applied = [];
    let wantClosure = false;

    if (message && lipsync && audio && isSpeaking) {
      const t = audio.currentTime;
      for (let i = 0; i < lipsync.mouthCues.length; i++) {
        const cue = lipsync.mouthCues[i];
        if (t >= cue.start && t <= cue.end) {
          const mt = corresponding[cue.value] || "viseme_PP";
          applied.push(mt);
          lerpMorphTarget(mt, clamp(VISEME_INTENSITY, 0, 1), VISEME_LERP);
          if (cue.end - t < 0.045) wantClosure = true;
          break;
        }
      }
    }

    if (wantClosure) {
      lerpMorphTarget("viseme_PP", WORD_CLOSURE, 0.5);
    }

    Object.values(corresponding).forEach((mt) => {
      if (!applied.includes(mt)) lerpMorphTarget(mt, 0, 0.22);
    });

    // Jaw from energy (+ wobble)
    const wobble = isSpeaking ? Math.sin((audio?.currentTime || 0) * 18) * 0.03 : 0;
    const targetJaw = isSpeaking ? clamp(JAW_MIN + energyNow * JAW_GAIN + wobble, 0, 1) : 0;
    lerpMorphTarget("jawOpen", targetJaw, 0.25);

    // Smile boost
    if (facialExpression === "smile") {
      lerpMorphTarget("mouthSmileLeft",  clamp(0.35 + energyNow * 0.2, 0, 0.8), 0.18);
      lerpMorphTarget("mouthSmileRight", clamp(0.35 + energyNow * 0.2, 0, 0.8), 0.18);
    }
  });

  // ---------- Leva panels ----------
  const [, set] = useControls("MorphTarget", () =>
    Object.assign(
      {},
      ...Object.keys(nodes.EyeLeft.morphTargetDictionary).map((key) => ({
        [key]: {
          label: key,
          value: 0,
          min: nodes.EyeLeft.morphTargetInfluences[nodes.EyeLeft.morphTargetDictionary[key]],
          max: 1,
          onChange: (val) => { if (setupMode) lerpMorphTarget(key, val, 1); },
        },
      }))
    )
  );

  useControls("FacialExpressions", {
    chat: button(() => chat()),
    winkLeft: button(() => { setWinkLeft(true);  setTimeout(() => setWinkLeft(false), 300); }),
    winkRight: button(() => { setWinkRight(true); setTimeout(() => setWinkRight(false), 300); }),
    animation: {
      value: animation,
      options: animations.map((a) => a.name),
      onChange: (value) => setAnimation(value),
    },
    facialExpression: {
      options: Object.keys(facialExpressions),
      onChange: (value) => setFacialExpression(value),
    },
    enableSetupMode: button(() => (setupMode = true)),
    disableSetupMode: button(() => (setupMode = false)),
  });

  // ---------- natural blink loop ----------
  useEffect(() => {
    let blinkTimeout;
    const nextBlink = () => {
      blinkTimeout = setTimeout(() => {
        setBlink(true);
        setTimeout(() => {
          setBlink(false);
          nextBlink();
        }, 200);
      }, THREE.MathUtils.randInt(1000, 5000));
    };
    nextBlink();
    return () => clearTimeout(blinkTimeout);
  }, []);

  // ---------- render ----------
  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh name="Wolf3D_Body"           geometry={nodes.Wolf3D_Body.geometry}           material={materials.Wolf3D_Body}           skeleton={nodes.Wolf3D_Body.skeleton} />
      <skinnedMesh name="Wolf3D_Outfit_Bottom"  geometry={nodes.Wolf3D_Outfit_Bottom.geometry}  material={materials.Wolf3D_Outfit_Bottom}  skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
      <skinnedMesh name="Wolf3D_Outfit_Footwear"geometry={nodes.Wolf3D_Outfit_Footwear.geometry}material={materials.Wolf3D_Outfit_Footwear}skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
      <skinnedMesh name="Wolf3D_Outfit_Top"     geometry={nodes.Wolf3D_Outfit_Top.geometry}     material={materials.Wolf3D_Outfit_Top}     skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
      <skinnedMesh name="Wolf3D_Hair"           geometry={nodes.Wolf3D_Hair.geometry}           material={materials.Wolf3D_Hair}           skeleton={nodes.Wolf3D_Hair.skeleton} />
      <skinnedMesh name="EyeLeft"               geometry={nodes.EyeLeft.geometry}               material={materials.Wolf3D_Eye}            skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}   morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}/>
      <skinnedMesh name="EyeRight"              geometry={nodes.EyeRight.geometry}              material={materials.Wolf3D_Eye}            skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}  morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}/>
      <skinnedMesh name="Wolf3D_Head"           geometry={nodes.Wolf3D_Head.geometry}           material={materials.Wolf3D_Skin}          skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}/>
      <skinnedMesh name="Wolf3D_Teeth"          geometry={nodes.Wolf3D_Teeth.geometry}          material={materials.Wolf3D_Teeth}         skeleton={nodes.Wolf3D_Teeth.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences}/>
    </group>
  );
}

useGLTF.preload("/models/68dcaeb39603200be5283efd (1).glb");
useGLTF.preload("/models/animations.glb");
